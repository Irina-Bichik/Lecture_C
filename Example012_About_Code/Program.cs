// Example: упрощение кода
bool Metodi(int chislo)
{
    bool resultati = false;
        if( chislo % 2==0 )
        { 
            resultati = true;
        }
        else
        {
            resultati = false; 
        }
        if (resultati == false)
        { 
            return false;
        } 
        else
        {
            return true;
        }
}
// Но нужно ли здесь делать много переходов на новую строку? Скорее нет, потому что выполняется одна
// инструкция для каждого из if или соответствующей ветки else. То есть мы наблюдаем присваивание
// нужного значения переменной или возвращение результата работы функции.
bool Metodi(int chislo)
{
    bool resultati = false;

    if (chislo % 2 == 0) { resultati = true; }
    else { resultati = false; }

    if (resultati == false) { return false; }
    else { return true; }
}
// Мы проверяем значение переменной resultati. Если resultati = false, возвращаем false, в противном случае — true.
// Метод, который называется Metodi, в качестве аргумента принимает целое число — chislo. Тело метода логическая переменная resultati, которой изначально присвоено значение лжи (false). 
// Производится проверка: если остаток от деления входного числа на 2 равен нулю, значение переменной resultati становится истиной (true), в противном случае — ложью (false).
// Дальше производится проверка: если результаты ложны, метод должен вернуть ложь, если нет — истину.
// что делает последняя проверка, последний if? Если результаты ложны, нужно вернуть ложь, иначе — истину. 
// Тогда не проще ли просто вернуть значение переменной resultati? 
bool Metodi(int chislo)
{
    bool resultati = false;

    if (chislo % 2 == 0) { resultati = true; }
    else { resultati = false; }

    return resultati;
}
// Теперь, если остаток от деления числа на 2 равен 0, мы просто будем возвращать истину. Если нет — ложь. Использование логической переменной абсолютно необоснованно. 
bool Metodi(int chislo)
{
    bool resultati = false;

    if (chislo % 2 == 0) { return true; }
    else { return false; }

}

// Дальше — результат деления числа на 2 либо истина (число разделилось), либо ложно (не разделилось). Что мы получаем? Что нам вообще не нужно делать проверку условия, достаточно
// написать в теле метода: «Верни результат проверки деления числа на 2». 
bool Metodi(int chislo)
{
    return chislo % 2 == 0;
}
//  Осталось дать нормальное имя методу и аргументу.
bool IsEven(int value)
{
    return value % 2 == 0;
}

// Используйте фишки языка

bool IsEven(int value) => value % 2 == 0;
var IsEven = (int v) => v % 2 == 0;

// Пример: использование неявной типизации
// как можно узнать тип переменной. Возьмём переменную a со значением 12. В консоли укажем a и через точку обратимся к методу GetType. 
int a = 12;
Console.WriteLine (a. GetType()); 
// или 
Console.WriteLine (a. GetType().Name);

// После запуска кода в консоли выдаст тип данных, который здесь описан, — это System.Int32. 
// Технически можем вместо int написать ключевое слово var, от этого ничего не поменяется.
var a = 12;
Console.WriteLine (a. GetType()); 

// смотрите не на то, насколько сложно написано, а на то, что написано, насколько читаем код. 
string text = "(1,2) (2,3) (4,5) (9,7)" // возьмите текст
.Replace ("(", "")
.Replace (")", ""); // замените в нём скобки
var data = text.Split(" ") // разбейте текст с учётом разделителя (внашем случае — пробела)
.Select (item => item.Split(',')) //сделайте выборку item, для которых нужно взять отдельную подстроку и разбить её на несколько элементов с учётом разделителя-запятой
.Select (e => (x: int.Parse (e[0]), 
y: int.Parse(e[1]))); //сделайте выборку из текущего массива,чтобы первой координатой был первый элемент массива (сразу конвертированный в число). То же — со второй
.Where (e => e.x % 2 == 0); //дайте такие пары, для которых первая координата — чётная
.Select (point => (point. x * 10, point. y)); //дайте набор, который мы получили на предыдущем этапе, и увеличьте первую координату
.ToArray (); //превратите в явный массив
for (int i = 0; i < data.length; i++)   // используйте в цикле с известными вам свойствами и функционалом
{
    Console.WriteLine(data [i]);   
}


